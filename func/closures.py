"""замыкание — это функция, которая помнит переменные из той функции,
внутри которой она была создана,
даже если та функция уже закончила работу."""

"""замыкания это функция которая дает дополнительную функциональность внутренней функции"""


def outer():        # внешняя функция
    n = 5           # переменная внутри outer
    def inner():    # внутренняя функция
        nonlocal n  # говорим, что будем использовать n из outer
        n += 1
        print(n)

    return inner    # возвращаем внутреннюю функцию
fn = outer()   # получили inner вместе с переменной n
fn()
fn()
fn()
fn()


"""
когда мы вызвали multiply(5), получилось замыкание: функция inner + значение n = 5.
теперь fn — это функция, которая всегда умножает на 5.
если бы мы сделали multiply(10), то получили бы функцию, которая всегда умножает на 10.
"""
def multiply(n):       # внешняя функция
    def inner(m):      # внутренняя функция
        return n * m   # использует n из внешней
    return inner

fn = multiply(5)   # "запомнили", что n = 5
print(fn(6))
print(fn(7))


"""итог: 
замыкание это когда функция запоминает переменные,
из той функции, внутри которой она была создана, даже после того как внешняя функция уже завершила работу
"""

def make_multiplier(k):
    def multiply(x):
        return k * x
    return multiply
times3 = make_multiplier(3)
times5 = make_multiplier(5)

print(times3(10))
print(times5(10))