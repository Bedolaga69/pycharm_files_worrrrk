"""замыкание — это функция, которая помнит переменные из той функции,
внутри которой она была создана,
даже если та функция уже закончила работу."""


def outer():        # внешняя функция
    n = 5           # переменная внутри outer
    def inner():    # внутренняя функция
        nonlocal n  # говорим, что будем использовать n из outer
        n += 1
        print(n)

    return inner    # возвращаем внутреннюю функцию
fn = outer()   # получили inner вместе с переменной n
fn()
fn()
fn()
fn()


"""
когда мы вызвали multiply(5), получилось замыкание: функция inner + значение n = 5.
теперь fn — это функция, которая всегда умножает на 5.
если бы мы сделали multiply(10), то получили бы функцию, которая всегда умножает на 10.
"""
def multiply(n):       # внешняя функция
    def inner(m):      # внутренняя функция
        return n * m   # использует n из внешней
    return inner

fn = multiply(5)   # "запомнили", что n = 5
print(fn(6))
print(fn(7))


"""итог: 
замыкание это когда функция запоминает переменные,
из той функции, внутри которой она была создана, даже после того как внешняя функция уже завершила работу
"""

def make_multiplier(k):
    def multiply(x):
        return k * x
    return multiply
times3 = make_multiplier(3)
times5 = make_multiplier(5)

print(times3(10))
print(times5(10))